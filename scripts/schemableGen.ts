import * as ts from 'typescript'
import * as Cons from 'fp-ts/Console'
import { pipe } from 'fp-ts/function'
import * as RA from 'fp-ts/ReadonlyArray'
import * as RTE from 'fp-ts/ReaderTaskEither'
import * as TE from 'fp-ts/TaskEither'
import { FileSystem, fileSystem } from './FS'
import { cli, CLI } from './CLI'
import { run } from './run'

interface Build<A> extends RTE.ReaderTaskEither<FileSystem & CLI, Error, A> {}

const _ = ts.factory

/**
 * Types that are injected into SchemableExt, follows:
 *
 * Category: List TypeName
 */
type SchemableCombinators = {
  date: ReadonlyArray<string>
  number: ReadonlyArray<string>
  string: ReadonlyArray<string>
}

// #region SchemableExt

/** Generate TS code for SchemableExt.ts */
declare const makeSchemableExtContents: (
  schemableCombinators: SchemableCombinators
) => string

// #endregion

/**
 * Different typeclasses which express a Schemable instance, follows:
 *
 * ["InstanceName", "I", "Schemable"] where index 0 is the proper name of the instance and
 * index 1 is the module accessor, and index 2 is the arity of the SchemableInstance
 */
export type SchemableTypeclasses =
  | ['Decoder', 'D', 'SchemableExt2C']
  | ['Eq', 'Eq', 'SchemableExt1']
  | ['Guard', 'G', 'SchemableExt1']
  | ['TaskDecoder', 'TD', 'SchemableExt2C']
  | ['Type', 't', 'SchemableExt1']

// #region Typeclass modules

export const moduleHeaderComment = `/**
 * SchemableExt intstances for Decoder
 *
 * **Warning: DO NOT EDIT, this module is autogenerated**
 *
 * @since 0.0.1
 */`

const makeModuleStarImport: (name: string, path: string) => ts.ImportDeclaration = (
  name,
  path
) =>
  _.createImportDeclaration(
    undefined,
    _.createImportClause(
      false,
      undefined,
      _.createNamespaceImport(_.createIdentifier(name))
    ),
    _.createStringLiteral(path),
    undefined
  )

const makeDestructureImport: (
  destructuredElements: ReadonlyArray<string>,
  path: string
) => ts.ImportDeclaration = (destructuredElements, path) =>
  _.createImportDeclaration(
    undefined,
    _.createImportClause(
      false,
      undefined,
      _.createNamedImports(
        pipe(
          destructuredElements,
          RA.map(el => _.createImportSpecifier(false, undefined, _.createIdentifier(el)))
        )
      )
    ),
    _.createStringLiteral(path),
    undefined
  )

const makeSchemableInstance: (
  tc: SchemableTypeclasses
) => (schemableCombinators: SchemableCombinators) => ts.VariableStatement =
  ([instanceName, accessor, schemableInstance]) =>
  schemableCombinators =>
    _.createVariableStatement(
      [_.createModifier(ts.SyntaxKind.ExportKeyword)],
      _.createVariableDeclarationList(
        [
          _.createVariableDeclaration(
            _.createIdentifier('Schemable'),
            undefined,
            _.createTypeReferenceNode(_.createIdentifier(schemableInstance), [
              _.createTypeReferenceNode(
                _.createQualifiedName(
                  _.createIdentifier(accessor),
                  _.createIdentifier('URI')
                ),
                undefined
              ),
            ]),
            _.createObjectLiteralExpression(
              [
                _.createSpreadAssignment(
                  _.createPropertyAccessExpression(
                    _.createIdentifier(schemableInstance),
                    _.createIdentifier('Schemable')
                  )
                ),
                _.createPropertyAssignment(
                  _.createIdentifier('Int'),
                  _.createPropertyAccessExpression(
                    _.createIdentifier('Int'),
                    _.createIdentifier('Decoder')
                  )
                ),
                ...pipe(
                  schemableCombinators.number,
                  RA.map(schemableCombinatorName =>
                    _.createPropertyAssignment(
                      _.createIdentifier(schemableCombinatorName),
                      _.createPropertyAccessExpression(
                        _.createIdentifier(schemableCombinatorName),
                        _.createIdentifier(instanceName)
                      )
                    )
                  )
                ),
                ...pipe(
                  schemableCombinators.string,
                  RA.map(schemableCombinatorName =>
                    _.createPropertyAssignment(
                      _.createIdentifier(schemableCombinatorName),
                      _.createPropertyAccessExpression(
                        _.createIdentifier(schemableCombinatorName),
                        _.createIdentifier(instanceName)
                      )
                    )
                  )
                ),
                ...pipe(
                  schemableCombinators.date,
                  RA.map(schemableCombinatorName =>
                    _.createPropertyAssignment(
                      _.createIdentifier(schemableCombinatorName),
                      _.createPropertyAccessExpression(
                        _.createIdentifier(schemableCombinatorName),
                        _.createIdentifier(instanceName)
                      )
                    )
                  )
                ),
              ],
              true
            )
          ),
        ],
        ts.NodeFlags.Const
      )
    )

/** Generate TS code for Decoder, Eq, Guard, TaskDecoder, or Type */
declare const makeSchemableInstanceModuleContents: (
  typeclass: SchemableTypeclasses
) => (schemableCombinators: SchemableCombinators) => string

// #endregion

/** Retrieve modules found in category folders */
const getSchemableCombinators: Build<SchemableCombinators> = C =>
  pipe(
    TE.Do,
    TE.apS('date', C.readFiles('./src/date')),
    TE.apS('number', C.readFiles('./src/number')),
    TE.apS('string', C.readFiles('./src/string'))
  )

const schemableTypeclasses: ReadonlyArray<SchemableTypeclasses> = [
  ['Decoder', 'D', 'SchemableExt2C'],
  ['Eq', 'Eq', 'SchemableExt1'],
  ['Guard', 'G', 'SchemableExt1'],
  ['TaskDecoder', 'TD', 'SchemableExt2C'],
  ['Type', 't', 'SchemableExt1'],
]

const main: Build<void> = pipe(
  getSchemableCombinators,
  // RTE.chainFirst(schemableCombinators =>
  //   pipe(
  //     makeSchemableExtContents(schemableCombinators), RTE.of, RTE.map(contents =>))
  // ),
  // RTE.chain(schemableCombinators =>
  //   pipe(
  //     schemableTypeclasses,
  //     RTE.traverseReadonlyArrayWithIndex((_, typeclass) =>
  //       pipe(
  //         schemableCombinators,
  //         makeSchemableInstanceModuleContents(typeclass),
  //         RTE.chain(writeSchemableInstanceModule(typeclass))
  //       )
  //     )
  //   )
  // ),
  RTE.chainFirstIOK(Cons.log),
  RTE.chainIOK(() => Cons.log('Done!'))
)

run(
  main({
    ...fileSystem,
    ...cli,
  })
)
